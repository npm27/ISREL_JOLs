install.packages(lrd)
install.packages('lrd')
install.packages("ggplot2")
install.packages("ez")
install.packages("reshape")
install.packages("stringr")
install.packages("stringi")
58000/12
58000 - 19900
19900 * .10
38100 * .12
4572 + 1990
58000-6562
51438/12
4286.5-400-430
3456.5-1005-120-220-500-200-75-60-100-200-100-30-10
90*4
3456.5-836.5
690+210+360+200+200+50+60+100+100
1970 / 2620
851.12*2
1702.24+820
2522.24 / 3456.5
15 * 20
300 * 4
1000
1000+3456
25.48/4
6.37831
6.37831*31
4300 - 1700
900 - 250
18.22*20
364*4
1456*12
1456*24
4833 * .70
3383 - 1005 - 30 - 30 - 400 - 100 - 175 - 200 - 50 - 200
58000 - 4664
5336 * .22
53336 * .22
40525 * .22
58000 - (4664 + 8915.5)
44420.5/12
58000 - 1990
56010 * .12
6721.2+1990
58000 - 8711.2
49288 / 12
1600/200
8 * .01
8*200
8 * .01
.08 * 200
1600/2
1/800
200 * 0.00125
ink = function(x){x * 0.0025}
ink(200)
200 * 0.00125
ink(100)
ink(100)
ink(300100)
ink(100)
200 * 0.00125
ink = function(x){x * 0.00125}
ink(200)
##convert ink to dollars
ink2dollars = function(x){x * 0.00125}
ink(200)
##convert ink to dollars
ink2dollars = function(x){x * 0.00125}
ink2dollars(500)
3000*12
install.packages("rsconnect")
setwd("~/GitHub/ISREL_JOLs/1 Analyses/Ex 1")
####Let's do some analyses!####
##set up
master = read.csv("Master Data Sheet.csv") #Loads the data set and saves it as dataframe called 'master'
summary(master) #lets see what we're working with here
#drop unused columns
#all we really need is EX Version, subject ID, JOL rating, RT, block, pair type, and whether or not they recalled it correctly
dat = master[ , -c(4, 11:12, 14:18)]
dat = dat[, -c(4:5, 7, 10)]
#okay, lets take another summary
summary(dat)
#JOLs are being treated as factor, we need to change this to a numeric variable so we can calculate means and what not
dat$JOL = as.numeric(as.character(dat$JOL))
#We also need to get JOLs and Recall on the same scale
colnames(dat)[7] = "Recall" #make the column name more helpful
dat$Recall = dat$Recall * 100
#Next, make a column for Experiment type
#split by condition and add column for condition type
read = subset(dat,
dat$ExperimentName == "READ_JOL A" | dat$ExperimentName == "READ_JOL B" | dat$ExperimentName == "READ_JOL C" | dat$ExperimentName == "READ_JOL D")
read$type = rep("READ")
RL = subset(dat,
dat$ExperimentName == "RL_JOL A" | dat$ExperimentName == "RL_JOL B" | dat$ExperimentName == "RL_JOL C" | dat$ExperimentName == "RL_JOL D")
RL$type = rep("RL")
IS = subset(dat,
dat$ExperimentName == "IS_JOL A" | dat$ExperimentName == "IS_JOL B" | dat$ExperimentName == "IS_JOL C" | dat$ExperimentName == "IS_JOL D")
IS$type = rep("IS")
#put the things back together
combined = rbind(read, RL, IS)
####Lets get descriptives####
summary(combined$JOL) #we have some out of range JOLs
combined$JOL[combined$JOL > 100] = NA #Get rid of them!
summary(combined$JOL)
#JOLs
tapply(combined$JOL,
list(combined$type, combined$Direction), mean, na.rm = T)
tapply(combined$Recall,
list(combined$type, combined$Direction), mean, na.rm = T)
####Let's check for outliers and see if this pattern holds####
#use the reshape package to get each subjects mean JOL and Recall score for each Direction
#First subset by EX Type
#We already have these from when we made the type column
library(reshape)
library(psychReport)
#remove missing
read = na.omit(read)
IS = na.omit(IS)
RL = na.omit(RL)
#READ INSTRUCTIONS
long.read = melt(read, id = c("Subject", 'ExperimentName',
"Block", "RT", "Direction", "type"))
summary(long.read)
colnames(long.read)[7] = "Task"
colnames(long.read)[8] = "Score"
#ITEM SPECIFIC
long.IS = melt(IS, id = c("Subject", 'ExperimentName',
"Block", "RT", "Direction", "type"))
summary(long.IS)
colnames(long.IS)[7] = "Task"
colnames(long.IS)[8] = "Score"
#RELATIONAL ENCODING
long.RL = melt(RL, id = c("Subject", 'ExperimentName',
"Block", "RT", "Direction", "type"))
summary(long.RL)
colnames(long.RL)[7] = "Task"
colnames(long.RL)[8] = "Score"
#Now get subject level means
#read condition
recall = subset(long.read,
long.read$Task == "Recall")
jol = subset(long.read,
long.read$Task == "JOL")
recall.read = cast(recall[ , -6], Subject ~ Direction, mean)
jol.read = cast(jol[ , -6], Subject ~ Direction, mean)
colnames(recall.read)[3] = "f"
colnames(jol.read)[3] = "f"
#Item Specific
recall = subset(long.IS,
long.IS$Task == "Recall")
jol = subset(long.IS,
long.IS$Task == "JOL")
recall.IS = cast(recall[ , -6], Subject ~ Direction, mean)
jol.IS = cast(jol[ , -6], Subject ~ Direction, mean)
colnames(recall.IS)[3] = "f"
colnames(jol.IS)[3] = "f"
#Relational processing
recall = subset(long.RL,
long.RL$Task == "Recall")
jol = subset(long.RL,
long.RL$Task == "JOL")
recall.RL = cast(recall[ , -6], Subject ~ Direction, mean)
jol.RL = cast(jol[ , -6], Subject ~ Direction, mean)
colnames(recall.RL)[3] = "f"
colnames(jol.RL)[3] = "f"
####Now Check for Outliers####
#start with Read
#JOLs
jol.read$zu = scale(jol.read$U)
jol.read$zs = scale(jol.read$S)
jol.read$zb = scale(jol.read$B)
jol.read$zf = scale(jol.read$f) #No z-score outliers for any, but keep an eye on 75
#Recall
recall.read$zu = scale(recall.read$U)
recall.read$zs = scale(recall.read$S)
recall.read$zb = scale(recall.read$B)
recall.read$zf = scale(recall.read$f) #No outliers
#Now do IS
#JOLs
jol.IS$zu = scale(jol.IS$U)
jol.IS$zs = scale(jol.IS$S)
jol.IS$zb = scale(jol.IS$B)
jol.IS$zf = scale(jol.IS$f) #No z-score outliers for any, but keep an eye on 18
#Recall
recall.IS$zu = scale(recall.IS$U)
recall.IS$zs = scale(recall.IS$S)
recall.IS$zb = scale(recall.IS$B)
recall.IS$zf = scale(recall.IS$f) #No outliers, but 8 is pretty low across the board
#Finally do RL
#JOLs
jol.RL$zu = scale(jol.RL$U)
jol.RL$zs = scale(jol.RL$S)
jol.RL$zb = scale(jol.RL$B)
jol.RL$zf = scale(jol.RL$f)
#Recall
recall.RL$zu = scale(recall.RL$U)
recall.RL$zs = scale(recall.RL$S)
recall.RL$zb = scale(recall.RL$B)
recall.RL$zf = scale(recall.RL$f)
##Note: We'll use the individual means for follow up t-tests
##make a long data set now for doing ANOVAs
anova_data = rbind(long.IS, long.read, long.RL)
####Okay, Lets run some ANOVAs now!####
library(ez)
#turn off scientific notation
options(scipen = 999)
unique(anova_data$Block)
length(unique(anova_data$Subject))
anova_data$Block = as.character(anova_data$Block)
#Note: Direction is within subjects, task is within subjects, ex type is between groups
output1 = ezANOVA(data = anova_data,
wid = Subject,
between = type,
within = .(Direction, Task),
dv = Score,
type = 3,
return_aov = T,
detailed = T)
output1
anovaLength = length(output1$ANOVA)
output1$ANOVA$MSE = output1$ANOVA$SSd/output1$ANOVA$DFd
output1$ANOVA$MSE
aovEffectSize(output1, effectSize = "pes")
length(unique(anova_data$Subject))
length(unique(anova_data$Subject)) #88 subjects
##supplemental stuff
tapply(anova_data$Score, anova_data$Block, mean, na.rm = T)
#overall score
tapply(anova_data$Score,
list(anova_data$type), mean)
tapply(anova_data$Score,
list(anova_data$Direction), mean)
#recall
anova_recall = subset(anova_data,
anova_data$Task == "Recall")
tapply(anova_recall$Score,
list(anova_recall$type, anova_recall$Direction), mean)
#jol
anova_jol = subset(anova_data,
anova_data$Task == "JOL")
tapply(anova_jol$Score,
list(anova_jol$type, anova_jol$Direction), mean)
#how many in each group?
length(tapply(anova_data$Subject,
anova_data$type, unique)[[1]]) #IS
length(tapply(anova_data$Subject,
anova_data$type, unique)[[2]]) #READ
length(tapply(anova_data$Subject,
anova_data$type, unique)[[3]]) #RL
####Get Means for Post-Hocs####
tapply(anova_data$Score, anova_data$Direction, mean) #main effect of direction
tapply(anova_data$Score, anova_data$Task, mean) #main effect of JOL vs Recall
tapply(anova_data$Score, anova_data$type, mean) #main effect of instruction type
tapply(anova_data$Score, list(anova_data$Task, anova_data$Direction), mean) #This is our two-way between task and direction
tapply(anova_data$Score, list(anova_data$Task, anova_data$Direction), mean) #This is our two-way between task and direction
head(anova_jol)
##break down the task x direction 2-way
jol2 = cast(anova_jol, Subject ~ Direction, mean)
recall2 = cast(anova_recall, Subject ~ Direction, mean)
View(recall2)
#do some t-tests
temp = t.test(jol2$F, recall2$F, paired = T, p.adjust.methods = "Bonferroni")
round(temp$p.value, 3)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
head(jol2)
pbic1 = jol2[ , c(1, 3)]
pbic2 = recall2[ . c(1, 3)]
pbic2 = recall2[ , c(1, 3)]
pbic1$task = rep("jol")
pbic2$task = rep("r")
pbic3 = cbind(pbic1, pbic2)
ezANOVA(pbic3,
wid = Subject,
dv = F,
between = task,
detailed = T)
pbic3
pbic3 = rbind(pbic1, pbic2)
ezANOVA(pbic3,
wid = Subject,
dv = F,
between = task,
detailed = T)
ezANOVA(pbic3,
wid = Subject,
dv = F,
within = task,
detailed = T)
#S
temp = t.test(jol2$S, recall2$S, paired = T, p.adjust.methods = "Bonferroni")
round(temp$p.value, 3)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
pbic1 = jol2[ , c(1, 4)]
pbic2 = recall2[ , c(1, 4)]
pbic1$task = rep("jol")
pbic2$task = rep("r")
pbic3 = rbind(pbic1, pbic2)
ezANOVA(pbic3,
wid = Subject,
dv = S,
within = task,
detailed = T)
#B
temp = t.test(jol2$B, recall2$B, paired = T, p.adjust.methods = "Bonferroni")
round(temp$p.value, 3)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
sd(jol2$B); sd(recall2$B)
sd(c(jol2$B, recall2$b)); sd(recall2$B)
sd(c(jol2$B, recall2$b))
sd(list(jol2$B, recall2$b))
sd(jol2$B); sd(recall2$B)
#U
temp = t.test(jol2$U, recall2$U, paired = T, p.adjust.methods = "Bonferroni")
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
sd(jol2$U); sd(recall2$U)
