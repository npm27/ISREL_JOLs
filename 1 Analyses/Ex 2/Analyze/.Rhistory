install.packages(lrd)
install.packages('lrd')
install.packages("ggplot2")
install.packages("ez")
install.packages("reshape")
install.packages("stringr")
install.packages("stringi")
58000/12
58000 - 19900
19900 * .10
38100 * .12
4572 + 1990
58000-6562
51438/12
4286.5-400-430
3456.5-1005-120-220-500-200-75-60-100-200-100-30-10
90*4
3456.5-836.5
690+210+360+200+200+50+60+100+100
1970 / 2620
851.12*2
1702.24+820
2522.24 / 3456.5
15 * 20
300 * 4
1000
1000+3456
25.48/4
6.37831
6.37831*31
4300 - 1700
900 - 250
18.22*20
364*4
1456*12
1456*24
4833 * .70
3383 - 1005 - 30 - 30 - 400 - 100 - 175 - 200 - 50 - 200
58000 - 4664
5336 * .22
53336 * .22
40525 * .22
58000 - (4664 + 8915.5)
44420.5/12
58000 - 1990
56010 * .12
6721.2+1990
58000 - 8711.2
49288 / 12
1600/200
8 * .01
8*200
8 * .01
.08 * 200
1600/2
1/800
200 * 0.00125
ink = function(x){x * 0.0025}
ink(200)
200 * 0.00125
ink(100)
ink(100)
ink(300100)
ink(100)
200 * 0.00125
ink = function(x){x * 0.00125}
ink(200)
##convert ink to dollars
ink2dollars = function(x){x * 0.00125}
ink(200)
##convert ink to dollars
ink2dollars = function(x){x * 0.00125}
ink2dollars(500)
3000*12
install.packages("rsconnect")
setwd("~/GitHub/ISREL_JOLs/1 Analyses/Ex 2/Analyze")
####Set up####
##read in data
dat = read.csv("Ex 2 Scored.csv")
##libraries
library(reshape)
library(ez)
library(psychReport)
library(Hmisc)
##turn of scientific notation
options(scipen = 999)
####Cleaning####
#fix jols
dat$JOL = as.numeric(dat$JOL) #get rid of any weird characters
dat$JOL[dat$JOL > 100] = NA #remove out of range values
#fix recall
dat$Scored = dat$Scored * 100 #get jols and recall on same scale
#Okay, what are we working with now?
summary(dat)
#remove the NAs
dat = na.omit(dat)
#get n
length(unique(dat$Sub.ID)) #102
##check for outliers/general weirdness
#any participants who got nothing correct? (shouldn't have to worry about cheating since in person!)
check_dat = cast(dat, Sub.ID ~ Direction, mean)
colnames(dat)[6] = "Recall"
##get data in long format
long.dat = melt(dat, measure.vars = c("JOL", "Recall"))
colnames(long.dat)[5] = "measure"
colnames(long.dat)[6] = "Score"
##descriptives
tapply(long.dat$Score, list(long.dat$measure, long.dat$Direction), mean) ##overall
#make the subsets
READ = subset(long.dat,
long.dat$Encoding == "READ")
IS = subset(long.dat,
long.dat$Encoding == "IS")
RL = subset(long.dat,
long.dat$Encoding == "RL")
##READ
tapply(READ$Score, list(READ$measure, READ$Direction), mean)
##IS
tapply(IS$Score, list(IS$measure, IS$Direction), mean)
##RL
tapply(RL$Score, list(RL$measure, RL$Direction), mean)
####ANOVA time####
model1 = ezANOVA(long.dat,
dv = Score,
between = Encoding,
within = .(measure, Direction),
wid = Sub.ID,
type = 3,
detailed = T)
model1
model1
#Get MSE here
model1$ANOVA$MSE = model1$ANOVA$SSd/model1$ANOVA$DFd
model1$ANOVA$MSE
#now get partial eta
aovEffectSize(model1, effectSize = "pes")
#now get partial eta
aovEffectSize(model1, effectSize = "pes")
#main effect of "measure" (diff between JOLs and recall is NS)
tapply(long.dat$Score, long.dat$measure, mean)
tapply(long.dat$Score, long.dat$Encoding, mean) #encoding group
tapply(long.dat$Score, long.dat$Encoding, mean) #encoding group
####t-tests####
##main effect of encoding group
encoding_group = cast(long.dat, Sub.ID ~ Encoding, mean)
View(encoding_group)
temp = t.test(encoding_group$IS, encoding_group$RL, paired = F, p.adjust.methods = "bonferroni")
temp
round(temp$p.value, 3)
temp$statistic
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
##IS vs Read
temp = t.test(encoding_group$IS, encoding_group$READ, paired = F, p.adjust.methods = "bonferroni")
##IS vs Read
temp = t.test(encoding_group$IS, encoding_group$READ, paired = F, p.adjust.methods = "bonferroni", var.equal = T)
temp
apply(encoding_group, 2, mean)
apply(encoding_group, 2, mean, na.rm = T)
apply(encoding_group, 2, sd, na.rm = T)
24*2
48+21
69-14
55-36
##significant effects
tapply(long.dat$Score, long.dat$Direction, mean) #direction
##main effect of pair direction
pair_type = cast(long.dat, Sub.ID ~ Direction, mean)
#F vs. S
temp = t.test(pair_type$F, pair_type$S, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
#F vs. S
temp = t.test(pair_type$F, pair_type$S, paired = F, p.adjust.methods = "bonferroni", var.equal = T)
temp
##GET VALUES FOR COMPUTING COHEN'S D
apply(encoding_group, 2, mean, na.rm = T)
##GET VALUES FOR COMPUTING COHEN'S D
apply(pair_type, 2, mean, na.rm = T)
apply(pair_type, 2, sd, na.rm = T)
#F vs. S
temp = t.test(pair_type$F, pair_type$S, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
#F vs. S
temp = t.test(pair_type$F, pair_type$S, paired = F, p.adjust.methods = "bonferroni", var.equal = T)
#F vs. S
temp = t.test(pair_type$F, pair_type$S, paired = F, p.adjust.methods = "bonferroni", var.equal = T)
temp
##GET VALUES FOR COMPUTING COHEN'S D
apply(pair_type, 2, mean, na.rm = T)
apply(pair_type, 2, sd, na.rm = T)
#now get partial eta
aovEffectSize(model1, effectSize = "pes")
tapply(long.dat$Score, list(long.dat$measure, long.dat$Direction), mean)
###Direction x Measure interaction
jol_dat = subset(long.dat,
long.dat$measure == "JOL")
recall_dat = subset(long.dat,
long.dat$measure == "Recall")
jol2 = cast(jol_dat, Sub.ID ~ Direction, mean)
recall2 = cast(recall_dat, Sub.ID ~ Direction, mean)
##F
temp = t.test(jol2$F, recall2$F, paired = F, p.adjust.methods = "bonferroni", var.equal = T)
temp
##F
temp = t.test(jol2$F, recall2$F, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
##B
temp = t.test(jol2$B, recall2$B, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
##S
temp = t.test(jol2$S, recall2$S, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
##U
temp = t.test(jol2$U, recall2$U, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
##get pbic for symmetrical
pbic 1 = jol2[ , c(1, 4)]
##get pbic for symmetrical
pbic1 = jol2[ , c(1, 4)]
pbic2 = recall2[ , c(1 ,4)]
pbic1$task = rep(jol)
pbic2$task = rep(recall)
pbic3 = rbind(pbic1, pbic2)
ezANOVA(pbic3,
wid = Sub.ID,
dv = U,
within = task,
detailed = T,
type = 3)
ezANOVA(pbic3,
wid = Sub.ID,
dv = S,
within = task,
detailed = T,
type = 3)
pbic1$task = rep('jol')
pbic2$task = rep('recall')
pbic1$task = rep('jol')
pbic3 = rbind(pbic1, pbic2)
ezANOVA(pbic3,
wid = Sub.ID,
dv = S,
within = task,
detailed = T,
type = 3)
ezANOVA(pbic3,
wid = Sub.ID,
dv = S,
within = task,
detailed = T,
type = 3)
##Now get values for computing d
apply(jol2, 2, mean, na.rm = T)
apply(recall2, 2, mean, na.rm = T)
apply(jol2, 2, sd, na.rm = T)
apply(recall2, 2, sd, na.rm = T)
##3-way interaction
tapply(READ$Score, list(READ$measure, READ$Direction), mean) #read
tapply(IS$Score, list(IS$measure, IS$Direction), mean) #item-specific
tapply(RL$Score, list(RL$measure, RL$Direction), mean) #relational
####post-hocs####
##split by jol and recall
#jol
is.jol = subset(IS,
IS$measure == "JOL")
rl.jol = subset(RL,
RL$measure == "JOL")
read.jol = subset(READ,
READ$measure == "JOL")
#recall
is.r = subset(IS,
IS$measure == "Recall")
rl.r = subset(RL,
RL$measure == "Recall")
read.r = subset(READ,
READ$measure == "Recall")
##Now make the post-hoc subsets
#jol
post.IS.jol = cast(is.jol, Sub.ID ~ Direction, mean)
post.READ.jol = cast(read.jol, Sub.ID ~ Direction, mean)
post.RL.jol = cast(rl.jol, Sub.ID ~ Direction, mean)
#recall
post.IS.r = cast(is.r, Sub.ID ~ Direction, mean)
post.READ.r = cast(read.r, Sub.ID ~ Direction, mean)
post.RL.r = cast(rl.r, Sub.ID ~ Direction, mean)
##Forward
#Read
temp = t.test(post.READ.jol$F, post.READ.r$F, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
#IS
temp = t.test(post.IS.jol$F, post.IS.r$F, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
#RL
temp = t.test(post.RL.jol$F, post.RL.r$F, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
##3-way interaction
tapply(READ$Score, list(READ$measure, READ$Direction), mean) #read
tapply(RL$Score, list(RL$measure, RL$Direction), mean) #relational
tapply(IS$Score, list(IS$measure, IS$Direction), mean) #item-specific
###Just do the three-way for now
##Backward
#Read
temp = t.test(post.READ.jol$B, post.READ.r$B, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
temp
round(temp$p.value, 3)
temp$statistic
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
#IS
temp = t.test(post.IS.jol$B, post.IS.r$B, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
temp
round(temp$p.value, 3)
temp$statistic
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
#RL
temp = t.test(post.RL.jol$B, post.RL.r$B, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
round(temp$p.value, 3)
temp$statistic
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
##read d
mean(post.READ.jol$B); mean(post.READ.r$B)
sd(post.READ.jol$B); sd(post.READ.r$B)
##IS pbic
pbic1 = post.READ.jol[ , c(1, )]
##IS pbic
pbic1 = post.READ.jol[ , c(1,3)]
pbic2 = post.READ.r[ , c(1,3)]
pbic1$task = rep("jol")
pbic2$task = reap("recall")
pbic2$task = rep("recall")
pbic3 = cbind(pbic1, pbic2)
ezANOVA(pbic3,
dv = B,
wid = Sub.ID
between = task,
ezANOVA(pbic3,
dv = B,
wid = Sub.ID,
between = task,
type = 3,
detailed = T)
##IS pbic
pbic1 = post.READ.jol[ , c(1,2)]
pbic2 = post.READ.r[ , c(1,2)]
pbic1$task = rep("jol")
pbic2$task = rep("recall")
pbic3 = cbind(pbic1, pbic2)
ezANOVA(pbic3,
dv = B,
wid = Sub.ID,
between = task,
type = 3,
detailed = T)
View(pbic3)
pbic3 = rbind(pbic1, pbic2)
ezANOVA(pbic3,
dv = B,
wid = Sub.ID,
between = task,
type = 3,
detailed = T)
ezANOVA(pbic3,
dv = B,
wid = Sub.ID,
within = task,
type = 3,
detailed = T)
##IS pbic
pbic1 = post.IS.jol[ , c(1,2)]
pbic2 = post.IS.r[ , c(1,2)]
pbic1$task = rep("jol")
pbic2$task = rep("recall")
pbic3 = rbind(pbic1, pbic2)
ezANOVA(pbic3,
dv = B,
wid = Sub.ID,
within = task,
type = 3,
detailed = T)
##RL pbic
pbic1 = post.RL.jol[ , c(1,2)]
pbic2 = post.RL.r[ , c(1,2)]
pbic1$task = rep("jol")
pbic2$task = rep("recall")
pbic3 = rbind(pbic1, pbic2)
ezANOVA(pbic3,
dv = B,
wid = Sub.ID,
within = task,
type = 3,
detailed = T)
##Forward
#Read
temp = t.test(post.READ.jol$F, post.READ.r$F, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
#IS
temp = t.test(post.IS.jol$F, post.IS.r$F, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
round(temp$p.value, 3)
temp$statistic
(temp$conf.int[2] - temp$conf.int[1]) / 3.92 #UNDER CONFIDENCE
#RL
temp = t.test(post.RL.jol$F, post.RL.r$F, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
#pbic rl
pbic1 = post.RL.jol[ , c(1,3)]
pbic2 = post.RL.r[ , c(1,3)]
pbic1$task = rep("jol")
pbic2$task = rep("recall")
pbic3 = rbind(pbic1, pbic2)
ezANOVA(pbic3,
dv = F,
wid = Sub.ID,
within = task,
type = 3,
detailed = T)
#pbic read
pbic1 = post.READ.jol[ , c(1,3)]
pbic2 = post.READ.r[ , c(1,3)]
pbic1$task = rep("jol")
pbic2$task = rep("recall")
pbic3 = rbind(pbic1, pbic2)
ezANOVA(pbic3,
dv = F,
wid = Sub.ID,
within = task,
type = 3,
detailed = T)
#d for is
mean(post.IS.jol$F); mean(post.IS.r$F)
sd(post.IS.jol$F); sd(post.IS.r$F)
##3-way interaction
tapply(READ$Score, list(READ$measure, READ$Direction), mean) #read
tapply(IS$Score, list(IS$measure, IS$Direction), mean) #item-specific
tapply(RL$Score, list(RL$measure, RL$Direction), mean) #relational
##Symmetrical
#Read
temp = t.test(post.READ.jol$S, post.READ.r$S, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
#IS
temp = t.test(post.IS.jol$S, post.IS.r$S, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92 #UNDER CONFIDENCE
#RL
temp = t.test(post.RL.jol$S, post.RL.r$S, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
#get d's
mean(post.READ.jol$S); mean(post.READ.r$S)
sd(post.READ.jol$S); sd(post.READ.r$S)
mean(post.IS.jol$S); mean(post.IS.r$S)
sd(post.IS.jol$S); sd(post.IS.r$S)
#get pbic
pbic1 = post.RL.jol[ , c(1,4)]
pbic2 = post.RL.r[ , c(1,4)]
pbic1$task = rep("jol")
pbic2$task = rep("recall")
pbic3 = rbind(pbic1, pbic2)
ezANOVA(pbic3,
dv = S,
wid = Sub.ID,
within = task,
type = 3,
detailed = T)
##3-way interaction
tapply(READ$Score, list(READ$measure, READ$Direction), mean) #read
tapply(IS$Score, list(IS$measure, IS$Direction), mean) #item-specific
tapply(RL$Score, list(RL$measure, RL$Direction), mean) #relational
##Unrelated
#Read
temp = t.test(post.READ.jol$U, post.READ.r$U, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
#IS
temp = t.test(post.IS.jol$U, post.IS.r$U, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
#RL
temp = t.test(post.RL.jol$U, post.RL.r$U, paired = T, p.adjust.methods = "bonferroni", var.equal = T)
temp
(temp$conf.int[2] - temp$conf.int[1]) / 3.92
#get ds
mean(post.READ.jol$U); mean(post.READ.r$U)
sd(post.READ.jol$U); sd(post.READ.r$U)
mean(post.IS.jol$U); mean(post.IS.r$U)
sd(post.IS.jol$U); sd(post.IS.r$U)
#PBIC
pbic1 = post.RL.jol[ , c(1,5)]
pbic2 = post.RL.r[ , c(1,5)]
pbic1$task = rep("jol")
pbic2$task = rep("recall")
pbic3 = rbind(pbic1, pbic2)
ezANOVA(pbic3,
dv = U,
wid = Sub.ID,
within = task,
type = 3,
detailed = T)
